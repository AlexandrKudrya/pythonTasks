# Работа со строками

## Исторический контекст и проблемы кодировок

### 1. Ранний период: Кодировка ASCII
В первые десятилетия компьютерной эры, **в 1950–60-х годах**, основным способом представления текстовой информации была кодировка **ASCII**. ASCII (Американский стандартный код для обмена информацией) использовал **7 бит** для кодирования каждого символа, что позволяло задать лишь 128`?` различных символов — латинский алфавит, цифры, базовые знаки препинания и _несколько управляющих символов_. В те времена такой набор был вполне достаточным, так как большинство вычислительных систем и программировались с учетом _английского языка_.

#### Характеристики ASCII:

- Использует **7 бит** для кодирования символа.
- Позволяет задать **128 символов**:
  - Латинский алфавит (буквы).
  - Цифры.
  - Базовые знаки препинания.
  - _Несколько управляющих символов_.

### 2. Переход к расширенным кодировкам

Со временем, с ростом популярности компьютеров и появлением вычислительной техники _в разных странах_, стало очевидно, что **ограниченного набора ASCII недостаточно** для представления символов других языков. Для решения этой проблемы были разработаны расширенные кодировки, такие как **ISO-8859**, которые позволяли использовать 8 бит на символ, расширяя число представляемых символов до 256. Однако каждая региональная кодировка, например **Windows-1251** для кириллицы, имела свои особенности. В результате обмен данными между системами, использующими разные кодовые страницы, нередко возникали проблемы совместимости, _когда одна и та же последовательность байтов могла интерпретироваться по-разному_.

#### Новые стандарты:
- **ISO-8859**:
  - Использует 8 бит на символ, расширяя число представляемых символов до 256.
- **Региональные кодировки**:
  - Например, Windows-1251 для кириллицы.
- **Проблемы**:
  - Различные кодировки имели свои особенности.
  - При обмене данными между системами возникали проблемы совместимости, так как одна и та же последовательность байтов могла интерпретироваться по-разному.

### 3. Революция Unicode и UTF-8

Для устранения этих сложностей в 1991 году был разработан стандарт Unicode. Целью Unicode было создать универсальную таблицу, которая позволила бы каждому символу, независимо от языка или письменности, иметь уникальный код. Такой подход значительно упростил международный обмен информацией, хотя изначально разработка Unicode сталкивалась с техническими вызовами по обеспечению гибкости и расширяемости стандарта. Одним из самых успешных воплощений Unicode стала кодировка UTF-8, которая использует от одного до четырех байт для представления каждого символа. Преимуществом UTF-8 является обратная совместимость с ASCII: все символы ASCII представлены одним байтом, что делает эту кодировку особенно удобной для постепенного перехода от старых систем.

#### Запуск стандарта Unicode (1991 год):
- Цель: Создать универсальную таблицу, где каждому символу, независимо от языка или письменности, присваивался бы уникальный код.
  - Преимущества:
    - Упрощает международный обмен информацией.
    - Обеспечивает поддержку множества языков и письменностей.
  - Кодировка UTF-8:
    - Использует от 1 до 4 байт для представления каждого символа.
    - Обратная совместимость с ASCII:
    - Символы ASCII представлены одним байтом, что облегчает переход от старых систем.
- Технические вызовы:
  - Изначально разработка Unicode сталкивалась с проблемами обеспечения гибкости и расширяемости стандарта.

---

## Строки в Python

**Строка в Python** – это **неизменяемая** _последовательность_ `символов`. Это означает, что любые операции над строкой возвращают новый объект.

#### Создание строк:

```python
s1 = "Hello, World!"
s2 = 'Python'
# Для многострочных строк:
s3 = """Многострочная
строка в Python"""
```

## Основные методы и операции со строками

### Методы для изменения и очистки строк

#### **Изменение регистра:**
```python
text = "Hello"
print(text.upper())  # "HELLO"
print(text.lower())  # "hello"
```

#### **Удаление лишних символов:**
```python
text = "  Привет, мир!!!  "
print(text.strip())   # "Привет, мир!!!"
print(text.lstrip())  # "Привет, мир!  "
print(text.strip().rstrip("!"))  # "  Привет, мир"
```

#### **Замена подстрок:**
```python
text = "Python is fun"
print(text.replace("fun", "awesome"))  # "Python is awesome"
```

### Поиск и проверка строк

#### **Поиск подстроки:**
```python
text = "Hello, World!"
index = text.find("World")
print(index)  # 7
```

#### **Подсчёт подстроки:**
```python
s = "banana"
print(s.count("a"))  # Выведет: 3
```

_Замечание_: Метод `index()` выдаст ошибку, если подстрока не найдена.

#### **Проверка начала и конца строки:**
```python
filename = "data.csv"
print(filename.endswith(".csv"))  # True
print(filename.startswith("data"))  # True
```

#### **Методы для проверки символов в строке**
```python
# isalpha() Проверяет, состоят ли все символы строки только из букв (без пробелов, цифр и знаков препинания).
s1 = "HelloWorld"
s2 = "Hello123"

print(s1.isalpha())  # Выведет: True
print(s2.isalpha())  # Выведет: False (так как присутствуют цифры)

# isdigit() Проверяет, состоят ли все символы строки исключительно из цифр.
num1 = "2023"
num2 = "20a3"

print(num1.isdigit())  # Выведет: True
print(num2.isdigit())  # Выведет: False (так как есть буква 'a')

# isalnum() Проверяет, состоит ли строка только из букв и цифр (без пробелов и спецсимволов).
s1 = "Python3"
s2 = "Python 3"

print(s1.isalnum())  # Выведет: True
print(s2.isalnum())  # Выведет: False (есть пробел)

```

### Разбиение и объединение строк

#### **Разбиение (split):**
```python
data = "apple,banana,cherry"
fruits = data.split(",")
print(fruits)  # ['apple', 'banana', 'cherry']
```

_Замечание_: Если в метод `split()` не передать аргумент, то разбиение произойдёт по пробелу. 

#### **Разбиение по подстроке:**
```python
s = "apple-banana-cherry"
result = s.partition("-")
print(result)  # Выведет: ('apple', '-', 'banana-cherry')
```

_Замечание_: Разбиение происходит по первому вхождению. 

#### **Объединение (join):**
```python
words = ["Hello", "World"]
sentence = " ".join(words)
print(sentence)  # "Hello World"
```

### Форматирование строк

#### **f-строки (начиная с Python 3.6):**
```python
name = "Анна"
print(f"Привет, {name}!")  # "Привет, Анна!"
```

#### **Метод .format():**
```python
age = 30
print("Возраст: {}".format(age))  # "Возраст: 30"
```

#### **Оператор %:**
```python
price = 9.99
print("Цена: %.2f" % price)  # "Цена: 9.99"
```

## Спецсимволы. 

В эру **печатных машинок** и **телетайпов** существовала необходимость управлять аппаратными устройствами с помощью специальных управляющих команд, не являющихся печатными символами.

#### ASCII и контрольные символы:

Стандарт ASCII включает набор из 128 символов, из которых первые 32 (от 0x00 до 0x1F) зарезервированы под управляющие коды.

### Экранированные символы:

- `\n` — перенос строки
- `\t` — табуляция
- `\\` — обратный слеш
- `\"` — кавычка внутри строки

```python
print("Первая строка\nВторая строка")
```

---


# Задачи:

## Задача 1. Счётчик символов

Напишите программу, которая принимает строку и возвращает кортеж с количеством букв (A-Z, a-z) и цифр (0-9).

## Задача 2. Форматирование даты

Преобразуйте строку вида "2023-10-05" в формат "05 октября 2023".

_Подсказка: Используйте разбиение строки и список с названиями месяцев_

```python
months = [
        "января", "февраля", "марта", "апреля",
        "мая", "июня", "июля", "августа",
        "сентября", "октября", "ноября", "декабря"
    ]
...
```

## Задача 3. Форматирование даты

Дана строка, например "aaaabbbccdd". Напишите функцию, возвращающую строку без повторяющихся символов, **сохраняя порядок**. Т.е. на выходе мы дождны получить `abcd`.

## Задача 4. Парольный проверятор

Создайте программу, на вход которой подаётся строка, а на выходе она говорит, сильный ли это пароль или нет. 

**Характеристики сильного пароля:**
- Длинна больше 8 символов.
- Есть буквы в верхнем регистре и в нижнем.
- Есть цифры.
- Есть что-то кроме символов и цифр. 
- Есть хотя бы 1 китайский иероглиф. (_Необязательно, но будет прикольно_)

## Задача 5. Обратный порядок слов

Переверните порядок слов в строке, например "Hello World! Python" → "Python World! Hello".

---


## Для продвинутых (приколы).  

### Появление escape-последовательностей

**Идея escape-последовательностей:** Чтобы дать возможность передавать более сложные команды, был зарезервирован специальный символ ESC (Escape, 0x1B).

- После символа ESC последовательность байтов интерпретируется не как обычный текст, а как команда для терминала или другого устройства.
- **Развитие:** На основе идеи escape-последовательностей были разработаны протоколы для управления устройствами отображения. Одним из самых известных является стандарт ANSI escape codes, разработанный для терминалов типа VT100.

### ANSI escape-коды: продвинутое форматирование текста

**Основной принцип:** **ANSI escape-коды** позволяют задавать форматирование текста (цвет, яркость, подчеркивание и т.д.) в терминальных приложениях. Такие коды начинаются с ESC, за которым следует символ [ и набор параметров, заканчивающийся буквой.

#### Примеры:

- `\x1b[31m` – устанавливает красный цвет текста.
- Пример использования в Python:
```python
print("\x1b[31mЭтот текст будет красным\x1b[0m")
```
- `\x1b[0m` – сбрасывает все установленные атрибуты, возвращая форматирование к стандартному.
- Более сложные последовательности могут комбинировать несколько параметров, например:
  - `\x1b[32;1m` – устанавливает яркий зеленый цвет текста (32 – зеленый, 1 – яркость).
  - `\x1b[44;37m` – задает синий фон (44) с белым текстом (37).
